# RAG Chat Storage Microservice (Spring Boot 3 + Java 21)

Production-style microservice to store **chat sessions** and **chat messages** generated by a RAG chatbot, including optional retrieved context (JSON).

## Tech stack

- Java 21 + Spring Boot 3
- PostgreSQL (JSONB for retrieved context)
- Flyway migrations
- **Security modes**:
  - `API_KEY` (simple case-study mode) OR
  - `JWT` (OAuth2 Resource Server)
- **Rate limiting**:
  - `REDIS` backend for multi-instance deployments (recommended)
  - `IN_MEMORY` fallback for single instance
- **Soft delete + retention purge job**
- Optional **application-level encryption at rest** (AES-GCM)
- Centralized logging with request correlation id (MDC)
- Global error handling (`@RestControllerAdvice`)
- Swagger/OpenAPI (`springdoc-openapi`)
- Docker + Docker Compose (includes Postgres + Redis + Adminer)

---

## Quick start (Docker)

1. Copy env file:
   ```bash
   cp .env.example .env
   ```
2. Edit `.env` and set a strong `APP_SECURITY_API_KEY` (if using `API_KEY` mode).

3. Start:
   ```bash
   docker compose up --build
   ```

- App: http://localhost:8080  
- Swagger UI: http://localhost:8080/swagger-ui/index.html  
- Adminer (DB UI): http://localhost:8081  

---

## Security

### Option A: API Key mode (default)

All business APIs require **two headers**:

- `X-API-Key: <APP_SECURITY_API_KEY>`
- `X-User-Id: <user id>`

**Authorization (roles)**

By default, roles are resolved from the database on every request:

- `APP_SECURITY_RESOLVE_ROLES_FROM_DB=true` (default)
- `APP_SECURITY_REQUIRE_USER_IN_DB=true` (default)

This means the `X-User-Id` must exist in `app_users` and be `active=true`. Roles come from `app_user_roles`
(e.g., `CHAT_READ`, `CHAT_WRITE`, `CHAT_DELETE`, `CHAT_ADMIN`).

For convenience, migration **V3** seeds:
- `u1` with `CHAT_ADMIN`
- `u2` with `CHAT_READ`

You can manage users/roles via the admin API:
- `POST /api/v1/admin/users`
- `PUT /api/v1/admin/users/{userId}/roles`


Example:

```bash
export API_KEY=change-me
export USER_ID=u-123
```

### Option B: JWT mode (OAuth2 Resource Server)

Set:
- `APP_SECURITY_MODE=JWT`
- Configure one of:
  - `SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_ISSUER_URI=...`
  - `SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_JWK_SET_URI=...`

Then call APIs with:
- `Authorization: Bearer <JWT>`

User scoping uses the JWT subject (`sub`) by default (`Authentication#getName()`).

---

## APIs

### Sessions

**Create session**
```bash
curl -X POST http://localhost:8080/api/v1/sessions \
  -H "X-API-Key: $API_KEY" -H "X-User-Id: $USER_ID" \
  -H "Content-Type: application/json" \
  -d '{"title":"My RAG Chat"}'
```

**List sessions (paginated)**
```bash
curl "http://localhost:8080/api/v1/sessions?page=0&size=20" \
  -H "X-API-Key: $API_KEY" -H "X-User-Id: $USER_ID"
```

**List favorites only**
```bash
curl "http://localhost:8080/api/v1/sessions?favorite=true" \
  -H "X-API-Key: $API_KEY" -H "X-User-Id: $USER_ID"
```

**Rename session**
```bash
curl -X PATCH "http://localhost:8080/api/v1/sessions/<SESSION_UUID>/rename" \
  -H "X-API-Key: $API_KEY" -H "X-User-Id: $USER_ID" \
  -H "Content-Type: application/json" \
  -d '{"title":"Renamed chat"}'
```

**Mark/unmark favorite**
```bash
curl -X PATCH "http://localhost:8080/api/v1/sessions/<SESSION_UUID>/favorite" \
  -H "X-API-Key: $API_KEY" -H "X-User-Id: $USER_ID" \
  -H "Content-Type: application/json" \
  -d '{"favorite":true}'
```

**Delete session (soft delete)**
```bash
curl -X DELETE "http://localhost:8080/api/v1/sessions/<SESSION_UUID>" \
  -H "X-API-Key: $API_KEY" -H "X-User-Id: $USER_ID"
```

### Messages

**Add message (with optional RAG context JSON)**
```bash
curl -X POST "http://localhost:8080/api/v1/sessions/<SESSION_UUID>/messages" \
  -H "X-API-Key: $API_KEY" -H "X-User-Id: $USER_ID" \
  -H "Content-Type: application/json" \
  -d '{
        "sender":"USER",
        "content":"What is the warranty for product X?",
        "context":{
          "retrievedDocuments":[
            {"source":"kb:products","id":"doc-17","score":0.91,"snippet":"..."}
          ]
        }
      }'
```

**Get message history (paginated)**
```bash
curl "http://localhost:8080/api/v1/sessions/<SESSION_UUID>/messages?page=0&size=50&order=asc" \
  -H "X-API-Key: $API_KEY" -H "X-User-Id: $USER_ID"
```

---

## Health checks

- Simple: `GET /api/v1/health`
- Actuator: `GET /actuator/health`

> Note: with `API_KEY` mode you must include API key + user id headers.  
> With `JWT` mode you must include `Authorization: Bearer ...`.

---

## Rate limiting (Redis-backed)

Default: **120 requests / 60 seconds** per identity (API-key mode = apiKey+userId, JWT mode = token/subject).

Tune via:
- `APP_RATE_LIMIT_CAPACITY`
- `APP_RATE_LIMIT_REFILL_DURATION_SECONDS`
- `APP_RATE_LIMIT_BACKEND=REDIS` (recommended for multi-instance)

---

## Soft delete + retention

- `DELETE /sessions/{id}` performs a **soft delete** (`deleted_at` set).
- A scheduled job permanently removes:
  - Soft-deleted sessions after `APP_RETENTION_SOFT_DELETE_GRACE_DAYS`
  - Inactive sessions (updated_at older than `APP_RETENTION_HARD_DELETE_AFTER_DAYS`)

Cron is configurable via `APP_RETENTION_CRON`.

---

## Encryption at rest (optional)

If you must encrypt sensitive fields at rest (e.g., message content/context), enable:

- `APP_ENCRYPTION_ENABLED=true`
- `APP_ENCRYPTION_PROVIDER=LOCAL`
- `APP_ENCRYPTION_LOCAL_KEY_BASE64=<base64 32-byte key>`

This uses AES-GCM and stores ciphertext with a prefix (`enc:v1:`). Responses are transparently decrypted by the API.

> Production note: prefer **envelope encryption with a KMS** (AWS KMS, GCP KMS, Azure Key Vault) to avoid managing raw keys in env vars.

---

## Local run (without Docker)

Requirements: Java 21, PostgreSQL 16+, Redis 7+ (if using REDIS rate limit)

```bash
export SPRING_DATASOURCE_URL=jdbc:postgresql://localhost:5432/ragchat
export SPRING_DATASOURCE_USERNAME=ragchat
export SPRING_DATASOURCE_PASSWORD=ragchat
export APP_SECURITY_MODE=API_KEY
export APP_SECURITY_API_KEY=change-me
mvn spring-boot:run
```

---

## Production hardening ideas

- Use **Redis / clustered** and add **ShedLock** so retention purge runs once across replicas.
- Replace the case-study identity header with full **OIDC/JWT scopes/roles** for authZ.
- Store encryption keys in a **KMS** and rotate keys periodically.
- Add per-tenant quotas, audit logs, and GDPR-style export/delete workflows.
